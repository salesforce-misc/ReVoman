= Re·πºoman (Rev-Woman)
Gopal S Akshintala <gopalakshintala@gmail.com>
:Revision: 1.0
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]
:hide-uri-scheme:
:toc:
:toc-placement!:
:sourcedir: src/main/kotlin
:testdir: src/integrationTest/java
:pmtemplates: src/integrationTest/resources/pm-templates
:imagesdir: docs/images
:prewrap!:
:revoman-version: 0.33.3

'''

*Re·πºoman* is an API automation tool for JVM (Java/Kotlin) from the API-first SaaS company, *Salesforce*. It re-imagines API automation by letting you execute a Postman collection in a JVM program/test.

'''

[.lead]
To start with, think of it as Postman for JVM (Java/Kotlin);
that emulates this *Run* button on a collection through a Java program,
essentially translating your manual testing into Automation, without any loss.
But it's even better!

image::postman-run.png[]

[.lead]
It strikes a balance between _flexibility_
provided by low-level tools like https://rest-assured.io/[**REST Assured**] and _ease of use_
provided by UI tools like https://www.postman.com/[**Postman**]

image::hybrid-tool.png[]

== Artifact

[.lead]
Maven
[source,xml,subs=attributes+]
----
<dependency>
  <groupId>com.salesforce.revoman</groupId>
  <artifactId>revoman</artifactId>
  <version>{revoman-version}</version>
</dependency>
----
[.lead]
Bazel
[source,bzl,subs=attributes+]
----
"com.salesforce.revoman:revoman"
----
[.lead]
Gradle Kts
[source,kts,subs=attributes+]
----
implementation("com.salesforce.revoman:revoman:{revoman-version}")
----

toc::[]

.Tech-Talk given at https://www.opensourceindia.in/osi-speakers-2023/gopala-sarma-akshintala/[Open Source Conf], https://speakerdeck.com/gopalakshintala/revoman-a-template-driven-api-automation-tool-for-jvm[üé¥Slide deck]
image::revoman-demo-thumbnail.png[link="https://www.youtube.com/watch?v=YxeRddSFkxc&list=PLrJbJ9wDl9EC0bG6y9fyDylcfmB_lT_Or&index=2"]

== Why Re·πºoman?

=== The Problem

* The majority of JVM SaaS applications are REST-based. But the API automation is done through a Mul-*T*-verse of Integration/Functional tests, E2E tests and Manual tests, each with its own frameworks, tools, and internal utilities, testing almost the same code flow.
* These custom alien automation frameworks, often built using low-level tools like https://rest-assured.io/[**REST Assured**] which are specific to a service or domain and are rigid to reuse, extend and difficult to maintain.
* This automation competes on cognitive complexity and learning curve with the Prod code, and mostly, automation wins.
* After a point, the API automation may deviate from its purpose of augmenting real end-user interaction and turns into a foot-chain for development.

image::cognitive-complexity.png[]

=== The Solution

Contrary to these custom frameworks,
almost every team uses https://www.postman.com/product/what-is-postman[*Postman*] for manual testing their APIs.
Postman collections contain a lot of information about your APIs and the order
in which they need to be executed for manual testing,
in a https://www.postman.com/templates/[Structured Template].
Leveraging it can mitigate writing a lot of code as we translate those manual steps into automation.

____

* How _productive_ would it be, if you can plug your exported Postman collection,
that you anyway would have created for your manual testing, and execute them through your JVM tests?

* How about a Universal API automation tool promotes low code and low-cognitive-complexity and strikes a balance between flexibility and ease of use?

____

== API automation with _Re·πºoman_

=== Template-Driven Testing

* The exported Postman collection JSON file is referred to as Postman templates, as it contains some placeholders/variables in the `+{{variable-key}}+` pattern. You can read more about it https://learning.postman.com/docs/sending-requests/variables/[here]
* Re·πºoman understands these templates and replaces these variables at the runtime, similar to Postman. It supports
** Nested variables, e.g., `+{{variable-key{{nested-variable-key}}}}+`
** link:{sourcedir}/com/salesforce/revoman/internal/postman/DynamicVariableGenerator.kt[Dynamic variables], e.g., `{{$randomUUID}}`, `{{$randomEmail}}`

[.lead]
You can _kick off_ this *Template-Driven Testing* by invoking `revUp`,
supplying your Postman templates and environments, and all your customizations through a configuration:

[source,java,indent=0,options="nowrap"]
----
final var rundown =
  ReVoman.revUp(
    Kick.configure()
     ...
    .off())
----

=== Simple Example

Here is a simple link:{pmtemplates}/restfulapidev/restful-api.dev.postman_collection.json[Exported Postman collection] and link:{pmtemplates}/restfulapidev/restful-api.dev.postman_environment.json[Environment],
to hit a free public https://restful-api.dev/[RESTFUL-API].
You can import and manually test this collection through the `Run collection` button like this:

image::resfulapi-dev-pm.png[]

You can automate the same
using Re·πºoman in a link:{testdir}/com/salesforce/revoman/integration/restfulapidev/RestfulAPIDevTest.java[Junit test]
by supplying the template and environment path:

ifdef::env-github[]

[source,java,indent=0,options="nowrap"]
.link:{testdir}/com/salesforce/revoman/integration/restfulapidev/RestfulAPIDevTest.java[RestfulAPIDevTest.java, tag=revoman-simple-demo]
----
@Test
@DisplayName("restful-api.dev")
void restfulApiDev() {
  final var rundown =
    ReVoman.revUp( // <1>
      Kick.configure()
          .templatePath(PM_COLLECTION_PATH) // <2>
          .environmentPath(PM_ENVIRONMENT_PATH) // <3>
          .off());
  assertThat(rundown.stepReports).hasSize(3);
}
----
<1> `revUp` is the method to call passing a configuration, built as below
<2> Supply an exported Postman collection JSON file path
<3> Supply an exported Postman environment JSON file path

endif::[]
ifndef::env-github[]

[source,java,indent=0,options="nowrap"]
.link:{testdir}/com/salesforce/revoman/integration/restfulapidev/RestfulAPIDevTest.java[RestfulAPIDevTest.java,tag=revoman-simple-demo]
----
include::{testdir}/com/salesforce/revoman/integration/restfulapidev/RestfulAPIDevTest.java[tag=revoman-simple-demo]
----
<1> `revUp` is the method to call passing a configuration, built as below
<2> Supply an exported Postman collection JSON file path
<3> Supply an exported Postman environment JSON file path

endif::[]

[#_rundown]
=== Rundown

After all this, you receive back a detailed *Rundown* in return.
It contains everything you need to know about what happened in an execution,
such that you can seamlessly run more assertions on top of the run.

[source,kotlin,indent=0,options="nowrap"]
----
Rundown(
  stepNameToReport: List<StepReport>,
  environment: PostmanEnvironment)

StepReport(
  step: Step,
  requestInfo: Either<RequestFailure, TxnInfo<Request>>? = null, // <1>
  preHookFailure: PreHookFailure? = null,
  responseInfo: Either<ResponseFailure, TxnInfo<Response>>? = null,
  postHookFailure: PostHookFailure? = null,
  envSnapshot: PostmanEnvironment<Any?> // <2>
)
----
<1> https://docs.vavr.io/#_either[`Either` type from the VAVR] library represents either of the two states, error or success
<2> Snapshot of Environment at the end of each step execution. It can be compared with previous or next step environment snapshots to see what changed in this step

[.lead]
`Rundown` has many convenience methods to ease applying further assertions on top of it.

TIP: Another simple example to see in Action: link:{testdir}/com/salesforce/revoman/integration/pokemon/PokemonTest.java[PokemonTest.java].

=== Advanced Example

[.lead]
Re·πºoman isn't just limited to that;
you can add more _bells & whistles_:

ifdef::env-github[]

[source,java,indent=0,options="nowrap"]
.link:{testdir}/com/salesforce/revoman/integration/core/pq/PQE2ETest.java[PQE2EWithSMTest.java, tag=pq-e2e-with-revoman-config-demo]
----
final var pqRundown =
    ReVoman.revUp( // <1>
        Kick.configure()
            .templatePaths(PQ_TEMPLATE_PATHS) // <2>
            .environmentPath(PQ_ENV_PATH) // <3>
            .dynamicEnvironment( // <4>
                Map.of(
                    "$quoteFieldsToQuery", "LineItemCount, CalculationStatus",
                    "$qliFieldsToQuery", "Id, Product2Id",
                    "$qlrFieldsToQuery", "Id, QuoteId, MainQuoteLineId, AssociatedQuoteLineId"))
            .customDynamicVariable( // <5>
                "$quantity", ignore -> String.valueOf(Random.Default.nextInt(10) + 1))
            .haltOnFailureOfTypeExcept(
                HTTP_STATUS_UNSUCCESSFUL,
                afterAllStepsContainingHeader("ignoreForFailure")) // <6>
            .requestConfig( // <7>
                unmarshallRequest(
                    beforeAllStepsWithURIPathEndingWith(PQ_URI_PATH),
                    PlaceQuoteInputRepresentation.class,
                    adapter(PlaceQuoteInputRepresentation.class)))
            .hooks( // <8>
                pre(
                    beforeAllStepsWithURIPathEndingWith(PQ_URI_PATH),
                    (step, requestInfo, rundown) -> {
                      if (requestInfo.containsHeader(IS_SYNC_HEADER)) {
                        LOGGER.info("Skip pricing for Sync step: {}", step);
                        rundown.mutableEnv.set("$pricingPref", PricingPref.Skip.toString());
                      } else {
                        rundown.mutableEnv.set("$pricingPref", PricingPref.System.toString());
                      }
                    }),
                post(
                    afterAllStepsWithURIPathEndingWith(PQ_URI_PATH),
                    (stepReport, ignore) -> {
                      validatePQResponse(stepReport); // <9>
                      LOGGER.info(
                          "Waiting in PostHook of the Step: {}, for the Quote's Asynchronous processing to finish",
                          stepReport.step.displayName);
                      // ! CAUTION 10/09/23 gopala.akshintala: This can be flaky until
                      // polling is implemented
                      Thread.sleep(5000);
                    }),
                post(
                    afterStepName("query-quote-and-related-records"),
                    (ignore, rundown) -> assertAfterPQCreate(rundown.mutableEnv)))
            .responseConfig( // <10>
                unmarshallResponse(
                    afterAllStepsWithURIPathEndingWith(PQ_URI_PATH),
                    PlaceQuoteOutputRepresentation.class))
            .customAdaptersForMarshalling(new IDAdapter()) // <11>
            .insecureHttp(true) // <12>
            .off()); // Kick-off
assertThat(pqRundown.firstUnIgnoredUnsuccessfulStepReport()).isNull(); // <13>
assertThat(pqRundown.mutableEnv)
    .containsAllEntriesOf(
        Map.of(
            "quoteCalculationStatusForSkipPricing", PricingPref.Skip.completeStatus,
            "quoteCalculationStatus", PricingPref.System.completeStatus,
            "quoteCalculationStatusAfterAllUpdates", PricingPref.System.completeStatus));
----
<1> `revUp` is the method to call passing a configuration, built as below
<2> Supply the path (relative to resources) to the Template Collection JSON file
<3> Supply the path (relative to resources) to the Environment JSON file
<4> Supply any dynamic environment that is runtime-specific
<5> <<#_custom-dynamic-variables, Custom dynamic variables>>
<6> <<#_execution_control>>
<7> <<#_type_safety_with_flexible_json_pojo_marshallingserialization_and_unmarshallingdeserialization, Request Config>>
<8> <<#_pre_and_post_hooks>>
<9> <<#_response_validations>>
<10> <<#_type_safety_with_flexible_json_pojo_marshallingserialization_and_unmarshallingdeserialization, Response Config>>
<11> <<#_type_safety_with_flexible_json_pojo_marshallingserialization_and_unmarshallingdeserialization, Custom Adapters>>
<12> Ignore Java cert issues when firing HTTP calls
<13> More assertions on top of <<#_rundown>>

endif::[]
ifndef::env-github[]

[source,java,indent=0,options="nowrap"]
.link:{testdir}/com/salesforce/revoman/integration/core/pq/PQE2ETest.java[PQE2ETest.java, tag=pq-e2e-with-revoman-config-demo]
----
include::{testdir}/com/salesforce/revoman/integration/core/pq/PQE2EWithSMTest.java[tag=pq-e2e-with-revoman-config-demo]
----
<1> `revUp` is the method to call passing a configuration, built as below
<2> Supply the path (relative to resources) to the Template Collection JSON file
<3> Supply the path (relative to resources) to the Environment JSON file
<4> Supply any dynamic environment that is runtime-specific
<5> <<#_custom-dynamic-variables, Custom dynamic variables>>
<6> <<#_execution_control>>
<7> <<#_type_safety_with_flexible_json_pojo_marshallingserialization_and_unmarshallingdeserialization, Request Config>>
<8> <<#_pre_and_post_hooks>>
<9> <<#_response_validations>>
<10> <<#_type_safety_with_flexible_json_pojo_marshallingserialization_and_unmarshallingdeserialization, Response Config>>
<11> <<#_type_safety_with_flexible_json_pojo_marshallingserialization_and_unmarshallingdeserialization, Custom Adapters>>
<12> Ignore Java cert issues when firing HTTP calls
<13> More assertions on top of <<#_rundown>>
endif::[]

== Debugging UX

[.lead]
This tool has particular emphasis on Debugging experience.

The rundown you get as a return from `revUp` after the execution completes has everything you need to know about what happened during each step execution,
along with environment snapshot during that step execution. Here is what a debugger view of a Rundown looks like:

image:rundown.png[Rundown of all steps]

[.lead]
üîç Let's zoom into a detailed view of one of those Step reports, which contains complete Request and Response info along failure information if any:

image:step-report.png[Step Report]

[.lead]
Here are the environment *key-value* pairs accumulated along the entire execution and appended to the environment from file and dynamicEnvironment supplied:

image:mutable-env.png[Mutable environment after the execution completion]

[.lead]
If something goes wrong at any stage during the Step execution, Re·πºoman *fails-fast* and captures the `Failure` in StepReport:

[#_step_execution]
image:step-execution.png[Step Execution]

[.lead]
Here is the failure hierarchy of what can go wrong in this process

[#_failure_hierarchy]
image::failure-hierarchy.png[Failure Hierarchy]

[.lead]
Re·πºoman logs all the key operations that happen inside its source-code.
Watch your console to check what's going on in the execution or troubleshoot from CI/CD logs

NOTE: link:docs/revoman.exe.log[üìùSample log] printed during execution

[#_logging]
image:pq-exe-logging.gif[Monitor Execution]

== Features

[#_type_safety_with_flexible_json_pojo_marshallingserialization_and_unmarshallingdeserialization]
=== Type Safety with flexible JSON <- -> POJO marshalling/serialization and unmarshalling/deserialization

* Re·πºoman internally uses a modern JSON library called https://github.com/square/moshi[**Moshi**]
* There may be a POJO that inherits or contains legacy classes which are hard or impossible to serialize. Re·πºoman lets you serialize such a legacy POJO by letting you pass `typesToIgnoreForMarshalling`, where you can filter-out these legacy classes.
* The payload may not map to POJO, and you may need a custom adapter for Conversion. Moshi has it covered for you with its advanced adapter mechanism and Re·πºoman accepts Moshi adapters via `requestConfig`, `responseConfig` and `customAdapters`
* Re·πºoman also comes bundled with link:{sourcedir}/com/salesforce/revoman/input/json/JsonReaderUtils.kt[JSON Reader utils] and link:{sourcedir}/com/salesforce/revoman/input/json/JsonWriterUtils.kt[JSON Writer utils] to help build Moshi adapters.

TIP: Refer link:{testdir}/com/salesforce/revoman/integration/core/pq/adapters/ConnectInputRepWithGraphAdapter.java[ConnectInputRepWithGraphAdapter]
for an advanced adapter use-case

* It also has link:{sourcedir}/com/salesforce/revoman/input/json/JsonPojoUtils.kt[JSON POJO Utils], which you can use to directly convert JSON to POJO and vice versa.

[#_execution_control]
=== Execution Control

The configuration offers methods through which the execution strategy can be controlled without making any changes to the template:

* `haltOnAnyFailure` ‚Äî This defaults to `false`. If set to `true`, the execution fails-fast when it encounters a failure.
* `haltOnFailureOfTypeExcept` ‚Äî This accepts pairs of `ExeType` and a `PostTxnStepPick` which are used to check if a Step can be ignored for failure for a specific failure type
* `runOnlySteps`, `skipSteps` ‚Äî All these accept a `predicate` of type `ExeStepPick`, which is invoked passing the current `Step` instance to decide whether to execute or skip a step.
** There are some `ExeStepPick` predicates bundled with Re·πºoman under `ExeStepPick.PickUtils` e.g `withName`, `inFolder` etc. You can write a custom predicate of you own too.

[#_pre_and_post_hooks]
=== Pre- and Post-Hooks

A hook lets you fiddle with the execution by plugging in your code before or after a Step execution.

[#_step_picks]
You can pass a `PreTxnStepPick/PostTxnStepPick` which is a `Predicate` used to qualify a step for Pre-/Post-Hook respectively. Re·πºoman comes bundled with some predicates under the namespace `PreTxnStepPick.PickUtils/PostTxnStepPick.PickUtils` e.g `beforeAllStepsWithURIPathEndingWith`, `afterStepName` etc. If those don't fit your needs, you can write your own custom predicates too.

[source,java,indent=0,options="nowrap"]
----
.hooks(
  pre(
      PreTxnStepPick,
      (currentStepName, requestInfo, rundown) -> {
        //...callback-code...
      }),
  post(
      PostTxnStepPick,
      (currentStepName, rundown) -> {
        //...callback-code...
      })
)
----

You can do things like assertion on the rundown, response validation, or environment and even <<#_mutable_environment,mutate the environment>>, such that the execution of subsequent steps picks up those changes.

[#_plug_in_your_java_code_in_between_postman_execution]
==== Plug-in your Java code in-between Postman execution

You can plug in your java code
to create/generate values for environment variables
which can be populated and picked-up by subsequent steps.
For example, you may want some `xyzId` but you don't have a Postman collection to create it.
But instead, you have a Java utility to generate/create it.
You can invoke the utility in a pre-hook of a step and set the value in `rundown.mutableEnv`,
so the subsequent steps can pick up value for `{+{xyzId}+}` variable from the environment.

[#_response_validations]
==== Response Validations

* Post-Hooks are the best place to validate response right after the step.
* If you have configured a strong type for your response through `responseConfig`, you can write type-safe validations by extracting your Strong type Object using `stepReport.responseInfo.get().<TypeT>getTypedTxnObj()` or `JsonPojoUtils.jsonToPojo()`
* If your response data structure is non-trivial and have requirements to execute validations with different strategies like `fail-fast` or `error-accumulation`, consider using a library like https://github.com/salesforce-misc/Vador[*Vador*]

[#_tests_js_support]
=== Tests JS support

* This tool can execute JavaScript written under the https://learning.postman.com/docs/writing-scripts/script-references/test-examples/[Tests tab of Postman]. Tests JS in a step is executed right after receiving an HTTP response.
* The intention of supporting Tests JS is to make sure the Postman collection used for manual testing can be used *as-is* for the automation also.
* Re·πºoman currently supports basic JS operations, and the support will be enhanced incrementally.
But the recommendation is not to add too much code here, as it is not intuitive to troubleshoot.Use it for simple operations like set environment variables and use Post-Hooks JVM code for any non-trivial operations.

[#_mutable_environment]
=== Mutable Environment

* Environment is the only mutable-shared state across step executions, which can be used for data-passing between consumer and the library.
* This can be mutated (set key-value pairs) through <<#_tests_js_support,Tests JS>> (using `pm.environment.set()`) and <<#_pre_and_post_hooks,Pre-/Post-Hooks>> (using the reference `rundown.mutableEnv`) during execution.

==== `pmEnvSnapshot` in each StepReport
Each StepReport also has a `pmEnvSnapshot` to assert if a step has executed as expected and compare snapshots from different steps to examine the execution progress.

=== Compose Modular Executions

* You don't have to squash all your steps into one mega collection. Instead, you can break them into easy-to-manage modular collections. `revUp` accepts a list of collection paths through `templatePaths`
* But that doesn't mean you have to execute all these templates in one-go.You can make multiple `revUp` calls.
* If you wish to compose these executions, you can do so by adding the previous execution's `mutableEnv` to current execution using `dynamicEnvironment` parameter. This also comes in handy when you wish to execute a common step (e.g. `UserSetup`) inside a test setup method and use that environment for all the tests.

[#_custom-dynamic-variables]
==== Custom Dynamic variables
If the in-built dynamic variables don't fit your need, you can plug your own dynamic variable generator,
to be invoked to generate a value for your custom variable-key in the template at runtime.

== USP

=== Low-code

TIP: Here is an example of a low-code link:{testdir}/com/salesforce/revoman/integration/core/pq/PQE2EWithSMTest.java[**E2E test**] that automates *~70 steps*

[.lead]
Compared to a traditional Integration/Functional or E2E test, approximately, the amount of code needed is *89%* less using Re·πºoman.
The above test doesn't just have low code, but also low in Cognitive Complexity and Transparent in what it does.

=== CI/CD integrability

* Re·πºoman is like any JVM library that you can plug into any JVM program/test (e.g., JUnit tests or Integration tests).
* Apart from adding a dependency in the build tool, there is *no extra setup needed* to execute these tests with Re·πºoman in CI/CD.

=== Up-to-date Postman collections that live along with Code in VCS

* A nice side effect is, this lets the Postman collections always stay up to date and the entire Postman collection guards each *check-in* in the form of a Test suite augmenting manual testing.
* Any day, you can find an up-to-date Postman collection for every feature you need to test, right in your VCS (Git) along with your code. Developers can import these templates directly from VCS into Postman for manual testing. This comes in very handy during a team blitz.

=== Unified framework for Automating __Persona-based__ Manual testing

* Re·πºoman brings a *Unified &amp; Simplified Test strategy* across the mul-**T**-verse (Integration Tests, E2E Tests, and Manual testing with Postman) for any API.
* The automation stays as close as possible to Persona-based Manual testing, leading to Transparency and better Traceability of issues
* This forces engineers to think like *API-first customers* while writing tests.
* *Test Data setup:* You can use the Re·πºoman for the Test data setup too. This eliminates the need for different teams to write their own internal utilities for data setup.
* *E2E Test* can even reside outside the Service repo, as long as it can hit the service API

== Perf

This entire execution of **~70 steps**, which includes **10 async steps**, took a mere *122 sec* on localhost.
This can be much better on auto-build environments.

image:pq-revoman-test-time.png[Localhost Test time on FTest console]

WARNING: Re·πºoman internally is very light-weight, and the execution times are proportional
to how your server responds or your network speed.

== Future

[.lead]
The future looks bright with multiple impactful features in the pipeline:

* API metrics and Analytics
* *It's built with extensibility* in mind. It can easily be extended to support other template formats, e.g., Kaiju templates used for availability testing.
* In-built polling support for Async steps
* Payload generation
* Flow control through YAML config

== FAQs

=== How to Debug a step in the middle of an Execution?

* You can add a <<#_pre_and_post_hooks,pre-hook>> to the Step you are interested and add a debug point inside that. This gets hit before Re·πºoman fires the request in that Step
* You can get more adventurous by attaching jar sources and directly adding conditional debug points inside the library source-code. You can search for logs in the source-code that indicate key operations to add conditional debug points with conditions like StepName etc.

=== Is there a way to Mark a Postman collection Step?

* You can add key-value pairs to a Step Header (e.g., `ignoreHTTPStatusUnsuccessful=true`).
* You can use this information in <<#_step_picks,Step Picks>> or <<#_pre_and_post_hooks>> to identify a particular step to execute any conditional logic

=== Do I need to migrate all my existing TestUtils to Postman Collections?

You don't have to.
This is a JVM first tool,
and you can interlace your TestUtils through <<#_plug_in_your_java_code_in_between_postman_execution,Pre-/Post-Hooks>>

=== Why not use https://learning.postman.com/docs/collections/using-newman-cli/command-line-integration-with-newman[Newman] or https://learning.postman.com/docs/postman-cli/postman-cli-overview/#comparing-the-postman-cli-and-newman[Postman CLI]?

* Re·πºoman may be similar to Newman or Postman CLI when it comes to executing a Postman collection, but the _similarities end there_.
* Newman or Postman CLI are built for node and cannot be executed within a JVM. Even if you are able to run with some hacky way, there is no easy way to assert results.
* Re·πºoman is JVM first that lets you configure a lot more, and gives you back a detailed report to assert in a typesafe way

== üôåüèº Consume-Collaborate-Contribute

* This link:CONTRIBUTING.adoc[CONTRIBUTING] doc has all the information to set up this library on your local and get hands-on.
* Any issues or PRs are welcome! ‚ô•Ô∏è
* Join this https://sfdc.co/revoman-slack[Slack Community] to discuss issues or PRs related to Consumption-Collaboration-Contribution
